{"version":3,"file":"poling.service.js","sourceRoot":"","sources":["../../src/services/poling.service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AACnD,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AACtE,OAAO,EAAE,UAAU,EAAY,OAAO,EAAgB,QAAQ,EAAE,MAAM,MAAM,CAAC;AAE7E;IAEE,wBAAoB,IAAY;QAAZ,SAAI,GAAJ,IAAI,CAAQ;IAAG,CAAC;IAEpC,mFAAmF;IACnF,gCAAO,GAAP,UACE,SAA8B,EAC9B,SAAwB;QAF1B,iBAqCC;QAnCC,0BAAA,EAAA,gBAAwB;QAExB,IAAM,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;QAC9B,IAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,UAAC,QAAqB;YACrD,IAAI,GAAiB,CAAC;YACtB,KAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;gBAC1B,IAAM,IAAI,GAAG,KAAI,CAAC,IAAI,CAAC;gBACvB,GAAG,GAAG,QAAQ,CAAC,SAAS,CAAC;qBACtB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;qBACzB,SAAS,CAAC;oBACT,IAAI,YAAC,MAAM;wBACT,IAAI,CAAC,GAAG,CAAC;4BACP,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACxB,CAAC,CAAC,CAAC;oBACL,CAAC;oBACD,KAAK,YAAC,GAAG;wBACP,IAAI,CAAC,GAAG,CAAC;4BACP,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;wBACtB,CAAC,CAAC,CAAC;oBACL,CAAC;iBACF,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC;gBACL,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACR,GAAG,CAAC,WAAW,EAAE,CAAC;gBACpB,CAAC;YACH,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC,IAAI,CAChB,SAAS,CAAC,OAAO,CAAC,EAClB,QAAQ,EAAE,EACV,KAAK,CAAC,SAAS,EAAE,CAAC,CACnB,CAAC;IACJ,CAAC;;gBA1CF,UAAU;;;;gBAJU,MAAM;;IA+C3B,qBAAC;CAAA,AA3CD,IA2CC;SA1CY,cAAc","sourcesContent":["import { Injectable, NgZone } from '@angular/core';\nimport { multicast, mergeMap, merge, refCount } from 'rxjs/operators';\nimport { Observable, Observer, Subject, Subscription, interval } from 'rxjs';\n\n@Injectable()\nexport class PoolingService {\n  constructor(private zone: NgZone) {}\n\n  // NOTE: Running the interval outside Angular ensures that e2e tests will not hang.\n  execute<T>(\n    operation: () => Observable<T>,\n    frequency: number = 1000\n  ): Observable<T> {\n    const subject = new Subject();\n    const source = Observable.create((observer: Observer<T>) => {\n      let sub: Subscription;\n      this.zone.runOutsideAngular(() => {\n        const zone = this.zone;\n        sub = interval(frequency)\n          .pipe(mergeMap(operation))\n          .subscribe({\n            next(result) {\n              zone.run(() => {\n                observer.next(result);\n              });\n            },\n            error(err) {\n              zone.run(() => {\n                observer.error(err);\n              });\n            }\n          });\n      });\n\n      return () => {\n        if (sub) {\n          sub.unsubscribe();\n        }\n      };\n    });\n\n    return source.pipe(\n      multicast(subject),\n      refCount(),\n      merge(operation())\n    );\n  }\n}\n"]}